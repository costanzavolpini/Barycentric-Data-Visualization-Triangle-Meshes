\label{section:vertex-area-chapter}
This section shows alternative methods to extend the idea of flat shading from triangles to vertices and edges. The idea of flat shading is to draw all the pixels of a triangle with the same colour. The extension of this approach is to split the surface of the triangle mesh likewise into regions around vertices and edges and draw all pixels in these regions with the same colour (Fig. \ref{fig:vertex-area}), thus visualizing data given at the vertices or edges of the mesh in a piecewise constant, not necessarily continuous way, resembling the classical triangle flat shading. The aforementioned regions can easily be defined using barycentric coordinates and a simple GPU fragment program (Fig. \ref{fig:max-diagram}) can be used to find out for each pixel to which region is belongs and which colour it should be painted with.

%%%%%%%%%%%%%


\begin{figure}[h]
    \centering
    \minipage[b]{.5\linewidth}
    \centering
    \includegraphics[scale=0.15]{images/max.png}
    \caption{Max diagram}\label{fig:max-diagram}
    \endminipage\hfill
    \minipage[b]{.5\linewidth}
    \centering
    \includegraphics[scale=0.15]{images/vertex-area.png}
    \caption{Region around a vertex}\label{fig:vertex-area}
    \endminipage
\end{figure}

%%%%%%%%%%%%%

\subsection{Max diagram - Vertex based area} \label{section:max-diagram}
Passing barycentric coordinates to the \textit{fragment shader} will clearly demonstrate that we can get results different from the classic color interpolation.
\cite{WEBSITE:redbloggames}
%----------
There are different approaches to color interpolation focusing on the distance from vertices. For each point in a triangle, we can easily determine its closest vertex, which we use as a cue for coloring.
A different approach from interpolating, can be found coloring vertex areas based on the minimum barycentric coordinate.
The color is given by the region farthest from a vertex (Fig. \ref{fig:max-diagram}, Pseudocode \ref{appendix:max-diagram}).

%%%%%%%%%%%%%

\subsection{Flat shading per vertex} \label{section:extend-flat-shading-lighting}
An extension of \textit{flat shading} would be to have each vertex area to be in one constant color. This color can be taken using the normal at the vertex and the vertex position.
The color will then be computed as in \textit{Gouraud shading}.
The idea is to compute the color per vertex but instead of linearly interpolated it in each triangle (as \textit{Gouraud shading} does) we color regions around a vertex with that constant color (using the GPU fragment program: max diagram \ref{section:max-diagram}).
To implement it, the barycentric coordinates, the vertex color, the normal at the vertex and the lighting calculations must be passed to the \textit{fragment shader}.
We want to avoid an automatic interpolation of colors, in order to return the resulting color using the \textit{max diagram}, we have used a \textit{Geometry shader} that have access to all three vertex colors in \textit{fragment shader}. (Pseudocodes: \ref{appendix:vs-flat-shading-lighting}, \ref{appendix:gs-flat-shading-lighting}, \ref{appendix:fs-flat-shading-lighting})

\begin{figure}[h]
    \centering
    \minipage[b]{.3\linewidth}
    \centering
    % \includegraphics[scale=0.15]{images/.png}
    \caption{Flat shading per triangle}\label{fig:flat-shading-triangle}
    \endminipage\hfill
    \minipage[b]{.3\linewidth}
    \centering
    \includegraphics[scale=0.5]{images/gouraudshading.png}
    \caption{Gouraud shading per triangle}\label{fig:gouraud-shading}
    \endminipage\hfill
    \minipage[b]{.3\linewidth}
    \centering
    \includegraphics[scale=0.5]{images/extentflatshading.png}
    \caption{Flat shading per vertex}\label{fig:flat-shading-vertex}
    \endminipage
\end{figure}


\subsubsection{Comparison}
\color{red}{TODO: add armadillo, horse, etc. images with these 3 effects (flat shading 1 and 2, gouraud shading)}
\color{black} %to remove after

%%%
\subsection{Gaussian curvature}
\label{section:vertex-area-gaussian-curvature}
Another interesting alternative data visualization technique is to compute the \textit{Gaussian curvature} per vertex. That can be done summing up, for each vertex, angles at this vertex with adjacent triangles and then subtracting this value to $2\pi$.
After having obtain this value, called \textit{angle defect} (Fig. \ref{fig:gc-angle}), we map linearly this value to a color range.
The resulting color will be the vertex flat shading visualisation of \textit{Gaussian curvature}.
$$K(V) = (2\pi - \sum_j \theta_j)/\mathcal{A}_{Mixed}$$
%%
\begin{figure}[!h]
    \centering
    \minipage[b]{.5\linewidth}
    \centering
    \scalebox{0.65}{\begin{tikzpicture}
        \coordinate (J) at (3.1,2.9);
        \coordinate (circle) at (3.1,2.9);
        \node[anchor=south west,inner sep=0] at (0,0) {\includegraphics[scale=0.2]{images/vertex-area.png}};
        \draw (J) node [below left] {$j$};
        \filldraw (2.8, 2.2) circle (2pt);
        \begin{scope}[line width=0.4mm, line cap=round]
            \draw (3.2,1.7) arc (295:360:0.7cm) node[near start,right] {$\theta_j$};
        \end{scope}
    \end{tikzpicture}}
    \label{fig:gc-angle}
    \endminipage\hfill
    \minipage[b]{.5\linewidth}
    \centering
    \includegraphics[scale=0.13]{images/gaussian-ball.png}
    \label{fig:gc-icosahedron}
    \endminipage
    \caption{On the left: angle defect is denoted with $\theta_j$. On the right: analysis that shows how constant vertex area should look on an icosahedron.}
\end{figure}
%%

\subsubsection{Local averaging regions} \label{section:localaveraging}
A mesh can be constructed either as the limit of a family of smooth surfaces or as a linear approximation of an arbitrary surface. To derive a spatial average of geometric properties we mix finite elements (a linear interpolation between three vertices of a triangle) and finite volumes (finite-volume region on a triangulated surface using Voronoi cells or Barycentric cells, Fig. \ref{fig:localregions}). Restricting the average to the neighboring triangles (\textit{1-ring}) we can choose for each vertex an associated surface patch over which the average will be computed.
Let's $\mathcal{A}_{Barycenter}$ be the area formed using barycenters and $\mathcal{A}_{Voronoi}$ the one formed using \textit{Voronoi} cell. The general case is represented by a point that can be anywhere, let's denote this surface area $\mathcal{A}_M$.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.35]{images/localregions.png}
    \label{fig:localregions}
    \caption{Local averaging regions used for computing discrete differential operators associated with the center vertex of the one-ring neighborhood. \cite{polygonmeshprocessing}}
\end{figure}
\textit{Voronoi} cell of each vertex is an appropriate local region that provide a stable error bounds.
The \textit{Voronoi} region for a point $P$ of a triangle non-obtuse $[P, Q, R]$ is expressed as $\frac{1}{8}(| PR|^2 cot \angle Q + |PQ |^2 cot \angle R)$. The sum of these areas for the whole \textit{1-ring neighborhood} gives the non-obtuse \textit{Voronoi} area for a vertex. The above expression for the \textit{Voronoi} finite-volume area does not hold in case of obtuse angles. Let's define a new surface area for each vertex denoted $\mathcal{A}_{Mixed}$. Essentially the idea is yo use the circumcenter point for each non-obtuse triangle and to use the midpoint of the edge opposite to the obtuse angle in case of an obtuse triangle. (See Pseudocode \ref{appendix:localaveraging}). \cite{meshlab}
%%%%%%%%

TODO: from there!!!!!!!! READ!!!!!!!!!!

\subsection{Constant Gaussian curvature per vertex}
\textit{Constant Gaussian curvature per vertex} returns a constant color around each vertex (Fig. \ref{fig:gc-icosahedron}, Pseudocode \ref{appendix:vs-gaussiancurvature}). After having calculated the \textit{Gaussian curvature} per vertex, this value is mapped in a color range to get the curvature color (for example: green for flat surfaces). This process is made separately for each vertex of the triangle and after using the technique explained above of max-diagram \ref{section:max-diagram} the resulting constant color is returned.

\subsection{Gouraud Gaussian curvature}
\textit{Gouraud Gaussian curvature} returns an interpolated color per vertex. The idea is to calculate the \textit{Gaussian curvature} as explained above (mapping the color in a color range to get the corresponding color per vertex) but instead of returning the constant color using a max-diagram approach, we just return the interpolation of the values obtained at each vertex of the triangle.


\subsubsection{Comparison}
We want now to compare the \textit{Gaussian curvature} (Fig. \ref{fig:gaussian-interpolated-horse}) with the \textit{interpolated Gaussian curvature}. In Fig. \ref{fig:gaussian-horse} each vertex area is colored applying the method \textit{max diagram} described in the above subsection \ref{section:max-diagram}. Instead, in Fig. \ref{fig:gaussian-interpolated-horse} the color is obtained with a linear interpolation.
% \begin{figure}[!htb]
% \centering
%   \minipage{0.4\textwidth}
%     % \includegraphics[width=\linewidth]{images/}
%     \caption{Interpolated Gaussian curvature} \label{fig:gaussian-interpolated-horse}
%   \endminipage\hfill
%   \centering
%   \minipage{0.4\textwidth}%
%     % \includegraphics[width=\linewidth]{images/gaussian-horse.png}
%     \caption{Gaussian curvature}\label{fig:gaussian-horse}
%   \endminipage
%   \end{figure}

Visualization of the principal curvatures of the model as colors from blue (highest values of curvature) to red (lower values of curvature), in both Fig. \ref{fig:gaussian-horse} and Fig. \ref{fig:gaussian-interpolated-horse}, better highlighs the geometry of the horse.
These changes of curvature, positive (blue), flat (green) and negative regions (red), better emphasises the 3-dimensionality of the model.
TODO
% \textit{Gaussian curvature} better shows the muscle constrasts given a more realistic character to the horse than the model obtained using the \textit{interpolated Gaussian curvature}.
