\subsection{Chapter 3}
\begin{lstlisting}[caption={Max diagram - Vertex based area (Section: \ref{section:max-diagram})\label{appendix:max-diagram}}]
if (Coords.x > Coords.y && Coords.x > Coords.z) {
    vec3 blue = vec3(0.0f, 0.0f, 1.0f);
    FragColor = vec4(blue, 1.0f);
} else if(Coords.y > Coords.x && Coords.y > Coords.z) {
    vec3 green = vec3(0.0f, 1.0f, 0.0f);
    FragColor = vec4(green, 1.0f);
} else {
    vec3 red = vec3(1.0f, 0.0f, 0.0f);
    FragColor = vec4(red, 1.0f);
}
\end{lstlisting}

\vspace{10pt}

\begin{lstlisting}[caption={Vertex Shader for flat shading extension using lighting (Section: \ref{section:extend-flat-shading-lighting})\label{appendix:vs-flat-shading-lighting}}]
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec3 aColor;

struct Light {
    // ...
};

out vec4 vertex_color;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    vec3 world_position = vec3(model * vec4(aPos, 1.0));
    vec3 world_normal = mat3(transpose(inverse(model))) * aNormal;

    // color obtained with lighting calculations
    vertex_color = get_result_color_lighting(...);

    gl_Position = projection * view * model * vec4(aPos, 1.0);
    }
\end{lstlisting}

\vspace{10pt}

\begin{lstlisting}[caption={Geometry Shader for flat shading extension (Section: \ref{section:extend-flat-shading-lighting})\label{appendix:gs-flat-shading-lighting}}]
#version 330 core
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in vec4 vertex_color[3];
out vec3 coords;
out vec4 wedge_color[3];

void main() {
    wedge_color[0] = vertex_color[0];
    wedge_color[1] = vertex_color[1];
    wedge_color[2] = vertex_color[2];

    coords = vec3(1.0, 0.0, 0.0);
    gl_Position = gl_in[0].gl_Position;
    EmitVertex();

    coords = vec3(0.0, 1.0, 0.0);
    gl_Position = gl_in[1].gl_Position;
    EmitVertex();

    coords = vec3(0.0, 0.0, 1.0);
    gl_Position = gl_in[2].gl_Position;
    EmitVertex();

    EndPrimitive();
}
\end{lstlisting}

\vspace{10pt}

\begin{lstlisting}[caption={Fragment Shader for flat shading extension (Section: \ref{section:extend-flat-shading-lighting})\label{appendix:fs-flat-shading-lighting}}]
#version 330 core
in vec3 coords;
in vec4 wedge_color[3];
out vec4 fragColor;

void main() {
    // max diagram
    if (coords[0] > coords[1]) {
        if (coords[0] > coords[2]) {
            fragColor = wedge_color[0];
        } else {
            fragColor = wedge_color[2];
        }
    } else {
        if (coords[1] > coords[2]) {
            fragColor = wedge_color[1];
        } else {
            fragColor = wedge_color[2];
        }
    }
}
\end{lstlisting}

\vspace{10pt}

\begin{lstlisting}[caption={Vertex Shader for flat shading extension using gaussian curvature (Section: \ref{section:extend-flat-gaussian-curvature})\label{appendix:vs-gaussiancurvature}}]
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 2) in vec3 gaussian_curvature;

out vec4 vertex_color;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

uniform float min_gc;
uniform float max_gc;
uniform float mean_negative_gc;
uniform float mean_positive_gc;


vec3 interpolation(vec3 v0, vec3 v1, float t) {
    return (1 - t) * v0 + t * v1;
}

vec4 get_result_color_gc() {
    float val = gaussian_curvature[0];
    vec3 red = vec3(1.0, 0.0, 0.0);
    vec3 green = vec3(0.0, 1.0, 0.0);
    vec3 blue = vec3(0.0, 0.0, 1.0);

    //negative numbers until 0 -> map from red to green
    if (val < 0) {
        return vec4(interpolation(red, green, val/min_gc)/(mean_negative_gc/5), 1.0);
    } else {
        //map from green to blue, from 0 to positive
        return vec4(interpolation(green, blue, val/max_gc)/(mean_positive_gc/5), 1.0);
    }
}

void main() {
    vec3 pos = vec3(model * vec4(aPos, 1.0));

    vertex_color = get_result_color_gc();

    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
\end{lstlisting}
